{
  "name": "iOSSwiftStarter",
  "tagline": "A sample iOS app written in Swift using the VIPER architecture.",
  "body": "# Little stories about an iOS application architecture in Swift\r\n\r\n![Swift logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_swift.png)\r\n\r\nBy writing this paper, my goal is to describe how I came up with the iOS app architecture I suggest.\r\nIt's a step by step writing to follow the reasons bringing me to set up the different components I chose.\r\n\r\nThe aim of the template application is very simple: it's a master/detail application to present a list of GitHub repositories of a given user.\r\nAlthough it's simple, it gathers some classical jobs when writing an application:\r\n\r\n* consume a REST API\r\n* save data to a local storage\r\n* load data from this local storage\r\n* architecture the logical layer and navigation between screens\r\n\r\nLet's discover what's hiding under the hood!\r\n\r\n***\r\n\r\n## Dependency management\r\n\r\nTo manage the dependencies to various tools and libraries our project will rely on, I chose to use [CocoaPods](https://cocoapods.org/) .\r\n\r\n![CocoaPods logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_cocoapods.png)\r\n\r\nFirst of all, I had to install it via:\r\n\r\n```\r\n$ sudo gem install cocoapods\r\n```\r\n\r\nThen I ran the following command in the root directory of the project:\r\n\r\n```\r\n$ pod init\r\n```\r\n\r\nIt creates the corresponding file named `Podfile`, where to put the dependencies.\r\n\r\nJust describe each one in the following way:\r\n\r\n```\r\nplatform :ios, '8.0'\r\nuse_frameworks!\r\n\r\ntarget 'MyApp' do\r\n  pod '{{LibraryName}}', '~> {{LibraryVersion}}'\r\nend\r\n```\r\n\r\nThen running\r\n\r\n```\r\n$ pod install\r\n```\r\n\r\nwill download each one in the `Pods` directory.\r\n\r\nThen, the project must be opened thanks to the following command line:\r\n\r\n```\r\nopen {{Project_Name}}.xcworkspace\r\n```\r\n\r\n## Consuming REST API\r\n\r\n### REST Client\r\n\r\nTo achieve HTTP networking in Swift, I chose to use one of the most popular libraries: [Alamofire](https://github.com/Alamofire/Alamofire).\r\n\r\n![Alamofire logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_alamofire.png)\r\n\r\nAlamofire\r\n \r\n* is very complete\r\n* has a fluent API\r\n* is very well unit tested and documented\r\n* has a cURL debug output (very nice tip)\r\n\r\nComing from a world of Android and Retrofit, I love a clean API service definition in a dedicated file.\r\nFollowing the Alamofire documentation, we can see, in the [CRUD & Authorization section](https://github.com/Alamofire/Alamofire#crud--authorization), that it's possible to define a Swift `enum` with methods matching the API service.\r\nThis enum must extend the `URLRequestConvertible` protocol.\r\n\r\nWhat we've got is a clean, readable, maintainable file bringing together all the needed API call methods, such as:\r\n\r\n```swift\r\nimport Alamofire\r\n\r\nenum ApiService: URLRequestConvertible {\r\n    static let baseURLString = \"https://api.github.com\"\r\n    \r\n    // MARK: API methods definitions\r\n    \r\n    case ListRepos(user: String, sort: ListReposSort?);\r\n    \r\n    // MARK: Parameters values for API methods\r\n    \r\n    enum ListReposSort {\r\n        case DESC;\r\n        case ASC;\r\n        var value: String {\r\n            switch self {\r\n            case .ASC:\r\n                return \"asc\";\r\n            case .DESC:\r\n                return \"desc\";\r\n            }\r\n        }\r\n    }\r\n    \r\n    // MARK: Verb definition according to API method\r\n    \r\n    var method: Alamofire.Method {\r\n        switch self {\r\n        case .ListRepos:\r\n            return .GET;\r\n        }\r\n    }\r\n    \r\n    // MARK: Path definition according to API method\r\n    \r\n    var path: (lastSegmentPath: String, parameters: [String: AnyObject]?) {\r\n        switch self {\r\n        case .ListRepos(let user, let sort) where sort != nil:\r\n            return (\"/users/\\(user)/repos\", [\"sort\": sort!.value]);\r\n        case .ListRepos(let user, _):\r\n            return (\"/users/\\(user)/repos\", nil);\r\n        }\r\n    }\r\n    \r\n    // MARK: URLRequestConvertible\r\n    \r\n    var URLRequest: NSMutableURLRequest {\r\n        let URL = NSURL(string: ApiService.baseURLString)!;\r\n        let mutableURLRequest = NSMutableURLRequest(URL: URL.URLByAppendingPathComponent(path.lastSegmentPath));\r\n        mutableURLRequest.HTTPMethod = method.rawValue;\r\n        let encoding = Alamofire.ParameterEncoding.URL;\r\n        \r\n        return encoding.encode(mutableURLRequest, parameters: path.parameters).0;\r\n    }\r\n}\r\n```\r\n\r\nNow just use it with Alamofire as follows:\r\n\r\n```swift\r\nAlamofire.request(ApiService.ListRepos(user: \"RoRoche\", sort: ApiService.ListReposSort.DESC))\r\n```\r\n\r\nHere we have in a single file:\r\n\r\n* the API base URL\r\n* the available methods\r\n* for each method, its parameters and the way to build its path\r\n* for each method, the HTTP Verb to use\r\n\r\nThe way to use it could vary according to the developer's philosophy or/and needs:\r\n\r\n* it could be a \"resource-oriented\" file (such as in AngularJS `resources` concept ; such as in Alamofire CRUD section of documentation)\r\n* it could distinguish authentificated calls\r\n* an enum file could correspond to one API method\r\n* etc.\r\n\r\nConclusion: at this step, we have an elegant way to define REST API calls.\r\n\r\nBut now, we have to consider dealing with the data obtained via the API.\r\nHere is the moment to talk about how to parse data (JSON content in this case).\r\n\r\n### Parsing data\r\n\r\nTo parse JSON data, I chose to use [ObjectMapper](https://github.com/Hearst-DD/ObjectMapper).\r\nIt's a well-known library in the Swift ecosystem.\r\n\r\nThe reason why I chose this one is for the following features:\r\n\r\n* it has a two-way binding between JSON and objects\r\n* it can deal with nested objects\r\n* it manages subclasses\r\n* it manages generic objects\r\n* it has ability to transform input data to specific outputs\r\n\r\nA `class`or `struct` simply has to respond to `Mappable` protocol by implementing:\r\n\r\n```swift\r\n    init?(_ map: Map)\r\n    mutating func mapping(map: Map)\r\n```\r\n\r\nSo it's possible to define variables with a given name to map a JSON key with a different name (could be convenient for specific needs).\r\n\r\nFirst, I define the data model to parse: here, a `Repo` class such as:\r\n\r\n```swift\r\nclass Repo {\r\n    var id: Int?;\r\n    var name: String?;\r\n    var owner: String?;\r\n    var avatarUrl: String?;\r\n    var desc: String?;\r\n    var createdAt: String?;\r\n    var gitUrl: String?;\r\n    var cloneUrl: String?;\r\n}\r\n```\r\n\r\nThen, I make it respond to the `Mappable` protocol thanks to the following code:\r\n\r\n```swift\r\n    required init?(_ map: Map) {\r\n    }\r\n    \r\n    func mapping(map: Map) {\r\n        id          <- map[\"id\"];\r\n        name        <- map[\"name\"];\r\n        owner       <- map[\"owner.login\"];\r\n        avatarUrl   <- map[\"owner.avatar_url\"];\r\n        desc        <- map[\"description\"];\r\n        createdAt   <- map[\"created_at\"];\r\n        gitUrl      <- map[\"git_url\"];\r\n        cloneUrl    <- map[\"clone_url\"];\r\n    }\r\n```\r\n\r\nHere is the ObjectMapper specific code. After that, the code to call the REST API through Alamofire and parse the results is the following:\r\n\r\n```swift\r\n        Alamofire.request(ApiService.ListRepos(user: user, sort: ApiService.ListReposSort.DESC))\r\n            .responseJSON { response in\r\n                if let JSON = response.result.value {\r\n                    let repos = Mapper<Repo>().mapArray(JSON);\r\n                    // deal with result\r\n                }\r\n        }\r\n```\r\n\r\nNow, a very personal point of view: I love separating logical layers to specific files/classes. Here we have two concepts:\r\n\r\n* on the one hand, a very simple object model, just defining variables\r\n* on the other hand, a specific mapping job responding to a peculiar protocol, with a dedicated method\r\n\r\nThat's where I'd like to introduce the Swift _extensions_ (powerful and interesting) concept.\r\nIt relies on the ability to add a behavior (i.e., functions) to a given class. Luckily, just what I described before!\r\n\r\nSo, I decided to create a new Swift file named `RepoDTO.swift` (the \"DTO\" notation references the DTO pattern commonly used in Web projects). It declares the `extension Repo` and declares the response to the `Mappable` protocol.\r\nIt just contains the implementation of the `mapping(map: Map)` function. I'd like to include the `Mappable.init` but such a required initializer must be located inside the original class.\r\n\r\nI know that it's typically a point of discussion:\r\n\r\n* some developers prefer to view all the API of a class in a single file\r\n* personally, I like to decouple logical segments in dedicated files to write lesser but more meaningful files\r\n\r\nI guess the introduction of CoreData concepts and code generation would show that it can be helpful to maintain such dedicated files, instead of fighting with diff tools to revert these \"custom\" code segments.\r\n\r\nConsidering Xcode organization advantages: it allows us to create groups matching the following logic:\r\n\r\n```\r\n\t{{ProjectName}}\r\n\t|_ \t{{ProjectMainFolder}}\r\n\t\t|_\tModel\r\n\t\t\t|_\tRepo.swift\r\n\t\t|_ REST\r\n\t\t\t|_\tApiService.swift\r\n\t\t\t|_ DTO\r\n\t\t\t\t|_\tRepoDTO.swift\r\n\r\n```\r\n\r\nN.B.: An extension is provided ([AlamofireObjectMapper](https://github.com/tristanhimmelman/AlamofireObjectMapper)) to use ObjectMapper to convert Alamofire responses.\r\n\r\n## Managing jobs\r\n\r\nHere we have the requests to a remote API and its parsing working. We could want to add an abstraction layer to isolate these two specific jobs in a single class.\r\n\r\nThat's why I decided to use [SwiftTask](https://github.com/ReactKit/SwiftTask).\r\n\r\nTo demonstrate how to use it, I first created a specific class to perform the REST call and the parsing.\r\nI called it `QueryListRepos` and made it extend `Task<Void, Array<Repo>, NSError>`.\r\n\r\nNow the deal is to configure it in its `init` using the `InitClosure` type. \r\nThe `init` method takes a `String` parameter corresponding to the `user` we are looking for.\r\nIn the `InitClosure`, we define the expected behavior as follows:\r\n\r\n```swift\r\nlet initClosure: InitClosure = { progress, fulfill, reject, configure in\r\n            \r\n    let request = Alamofire.request(ApiService.ListRepos(user: user, sort: ApiService.ListReposSort.DESC))\r\n        .responseJSON { response in\r\n                \r\n            if(response.result.error != nil) {\r\n                reject(response.result.error!);\r\n            } else {\r\n                if let JSON = response.result.value {\r\n                    // JSON parsing\r\n                    let repos: Array<Repo> = Mapper<Repo>().mapArray(JSON)!;\r\n                            \r\n                    // finish with success\r\n                    fulfill(repos);\r\n                } else {\r\n                    // finish with error\r\n                    let error: NSError = NSError(domain: \"JSON parsing\", code: 0, userInfo: [:]);\r\n                    reject(error);\r\n                }\r\n            }                    \r\n    }\r\n            \r\n    debugPrint(request);\r\n            \r\n    // we plug the cancel method of the Task to the cancel method of the request\r\n    configure.cancel = {\r\n        request.cancel();\r\n    }\r\n};\r\n```\r\n\r\nThen we just have to call the `super.init` method in the following manner:\r\n\r\n```swift\r\nsuper.init(weakified: false, paused: false, initClosure: initClosure);\r\n```\r\n\r\nAnd here we are: everywhere from the project, we can start this HTTP request and JSON parsing simply by writing:\r\n\r\n```swift\r\nlet task = QueryListRepos(user: \"a given user\")\r\n```\r\n\r\nNow we can set up the `success` and `failure` callbacks for this task. A valuable advantage is that we can configure these callbacks inside the `init` method of the task, and after starting it in the considered component.\r\n\r\n* In the task `init` function:\r\n\r\n```swift\r\nclass QueryListRepos: Task<Void, Array<Repo>, NSError> {\r\n    init(user: String!) {\r\n        let initClosure: InitClosure = { progress, fulfill, reject, configure in\r\n            // ...\r\n        };\r\n        \r\n        super.init(weakified: false, paused: false, initClosure: initClosure);\r\n        \r\n        self.success { (value: Array<Repo>) -> Void in\r\n            print(\"[QueryListRepos:init] task success\");\r\n        }.failure { (error: NSError?, isCancelled: Bool) -> Void in\r\n            print(\"[QueryListRepos:init] task failure\");\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n* In the view controller:\r\n\r\n```swift\r\nlet task = QueryListRepos(user: user);\r\ntask.success { (value: Array<Repo>) -> Void in\r\n    print(\"[ViewController:listRepos] task success\");\r\n}.failure { (error: NSError?, isCancelled: Bool) -> Void in\r\n    print(\"[ViewController:listRepos] task failure\");\r\n}\r\n```\r\n\r\nIt provides the following output:\r\n\r\n```\r\n[QueryListRepos:init] task success\r\n[ViewController:listRepos] task success\r\n```\r\n\r\nThe conclusion is: we can handle success/failure at task level (for a generic purpose for example) and in the starter component (for specific jobs ; in a view controller for example).\r\n\r\n## Communication between components with passing data\r\n\r\nA typical example of a generic purpose that could be achieved in success/failure callbacks at task level is to fire a `NSNotification` to notify other components that the task is complete.\r\n\r\nThe `NSNotification` concept in iOS is interesting by itself. Through the `NSNotificationCenter`, it becomes possible to communicate between various components in a same application, and transmit data to observer(s).\r\n\r\nPersonally, I have been using it for many years now. Nevertheless, I'd like to have a more fluent syntax to set up my notifications and their observer(s). To solve this point, I found the following library: [Kugel](https://github.com/TakeScoop/Kugel).\r\n\r\n![Kugel logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_kugel.png)\r\n\r\nJust what I need: \r\n\r\n* a wrapper to easily publish a notification, \r\n* to subscribe to one or more notifications at the same time \r\n* and unsubscribe from all notifications in one line.\r\n\r\nSimple, effective.\r\n\r\nSo I've just defined an abstract class to encapsulate a common job for a termination query event.\r\n\r\nHere is the code:\r\n\r\n```swift\r\npublic class AbstractQueryNotification {\r\n    \r\n    private struct UserInfo {\r\n        static let Results: String = \"results\";\r\n        static let Error: String = \"error\";\r\n        static let IsCancelled: String = \"isCancelled\";\r\n    }\r\n    \r\n    public class func buildUserInfoSuccess<T where T: AnyObject>(results: T) -> [NSObject: AnyObject] {\r\n        let userInfo: [String: AnyObject] = [\r\n            UserInfo.Results:results\r\n        ];\r\n        \r\n        return userInfo;\r\n    }\r\n    \r\n    public class func buildUserInfoFailure(error: NSError, isCancelled: Bool) -> [NSObject: AnyObject] {\r\n        let userInfo: [String: AnyObject] = [\r\n            UserInfo.Error: error,\r\n            UserInfo.IsCancelled: isCancelled\r\n        ];\r\n        \r\n        return userInfo;\r\n    }\r\n    \r\n    private class func getUserInfoForKey<T>(notification: NSNotification, key: String) -> T? {\r\n        let userInfo: [NSObject: AnyObject] = notification.userInfo as [NSObject: AnyObject]!;\r\n        \r\n        var ret: T? = nil;\r\n        \r\n        if let value = userInfo[key] {\r\n            ret = value as? T\r\n        }\r\n        \r\n        return ret;\r\n    }\r\n    \r\n    public class func results<T>(notification: NSNotification) -> T? {\r\n        return getUserInfoForKey(notification, key: UserInfo.Results);\r\n    }\r\n    \r\n    public class func error(notification: NSNotification) -> NSError? {\r\n        return getUserInfoForKey(notification, key: UserInfo.Error);\r\n    }\r\n    \r\n    public class func isCancelled(notification: NSNotification) -> Bool? {\r\n        return getUserInfoForKey(notification, key: UserInfo.IsCancelled);\r\n    }\r\n}\r\n```\r\n\r\nIt provides an elegant facade to build notifications and retrieve user’s info thanks to the helper method.\r\n\r\nNow, in the success/failure callbacks at task level, I've just to call the following:\r\n\r\n```swift\r\nself.success { (value: Array<Repo>) -> Void in\r\n    let userInfo: [NSObject: AnyObject] = OnQueryListReposDidFinish.buildUserInfoSuccess(value as AnyObject);\r\n    Kugel.publish(OnQueryListReposDidFinish.Name, object: self, userInfo:userInfo);\r\n}.failure { (error: NSError?, isCancelled: Bool) -> Void in\r\n    let userInfo: [NSObject: AnyObject] = OnQueryListReposDidFinish.buildUserInfoFailure(error!, isCancelled: isCancelled);\r\n    Kugel.publish(OnQueryListReposDidFinish.Name, object: self, userInfo:userInfo);\r\n}\r\n```\r\n\r\nFinally, just register a component (here, for example, a view controller) to be notified, in the following way:\r\n\r\n```swift\r\nclass /*MyCustom*/ViewController: /*Super*/ViewController/*, {{optional protocols}}*/ {\r\n    \r\n    // ...\r\n    \r\n    // MARK: - Lifecycle\r\n    \r\n    override func viewDidLoad() {\r\n        super.viewDidLoad()\r\n        \r\n        // ...\r\n        \r\n        Kugel.subscribe(self, name: OnQueryListReposDidFinish.Name, selector: \"onQueryListReposDidFinish:\");\r\n    }\r\n    \r\n    deinit {\r\n        Kugel.unsubscribeAll(self);\r\n    }\r\n    \r\n    // MARK: - Notifications management\r\n    \r\n    func onQueryListReposDidFinish(notification: NSNotification) {\r\n        let query: QueryListRepos = notification.object as! QueryListRepos;\r\n        let results: Array<Repo>? = OnQueryListReposDidFinish.results(notification);\r\n        let error: NSError? = OnQueryListReposDidFinish.error(notification);\r\n        let isCancelled: Bool? = OnQueryListReposDidFinish.isCancelled(notification);\r\n        \r\n        // TODO: deal with notification\r\n    }\r\n    \r\n    // ...\r\n}\r\n```\r\n\r\nAfter that, a component can be notified and can handle data passing through the notification (and don't forget to unregister itself in the `deinit` method).\r\n\r\n## Data persistence\r\n\r\nThe entry point of the local storage is to use the built-in tool provided by Apple: [CoreData](https://developer.apple.com/library/tvos/documentation/Cocoa/Conceptual/CoreData/index.html).\r\n\r\nIt provides a powerful system of storage, a user-friendly interface to declare model and automatic code generation.\r\n\r\nNevertheless, developers can expect another layer of abstraction in order to provide a fluent API and clear method calls to simplify daily work and delete boilerplate code.\r\n\r\n#### Final choice: CoreStore\r\n\r\nVarious libraries exist to provide a nice solution to my previously mentioned problem:\r\n\r\n* [ActiveRecord](https://github.com/kaneshin/ActiveRecord)\r\n* [SwiftRecord](https://github.com/arkverse/SwiftRecord)\r\n* [SuperRecord](https://github.com/michaelarmstrong/SuperRecord)\r\n* [CoreStore](https://github.com/JohnEstropia/CoreStore)\r\n* [SugarRecord](https://github.com/SwiftReactive/SugarRecord)\r\n\r\nI've decided to use CoreStore since it has very complete features and its API is fluent as well (a single line produces a set of coherent operations).\r\n\r\nAfter declaring the entities in the traditional way (i.e., using `.xcdatamodel` file and generating `NSManagedObject`), I can set up CoreStore.\r\n\r\nFirst, I define a singleton class to manage the `DataStack` object from CoreStore. I simply use it in its default configuration. The code is the following:\r\n\r\n```swift\r\nimport CoreStore\r\n\r\nfinal class DataStoreManager: NSObject {\r\n    \r\n    // MARK: - Singleton set up\r\n    \r\n    static let sharedInstance = DataStoreManager();\r\n    \r\n    private override init() {\r\n        super.init();\r\n        \r\n        // This prevents others from using the default '()' initializer for this class.\r\n        \r\n        self.synthesizeDataStoreManager();\r\n    }\r\n    \r\n    // MARK: - CoreStore specific job\r\n    \r\n    private static let fileName: String = \"POC.sqlite\";\r\n    \r\n    let dataStack = DataStack();\r\n    \r\n    private func synthesizeDataStoreManager() {\r\n        try! self.dataStack.addSQLiteStoreAndWait(fileName: DataStoreManager.fileName);\r\n    }\r\n}\r\n```\r\n\r\nThen, I edit the `QueryListRepos` class so that, after parsing the JSON data, we store it in the `DataStack` as follows:\r\n\r\n```swift\r\nDataStoreManager.sharedInstance.dataStack.beginSynchronous({ (transaction) -> Void in\r\n    let deleted: Int = transaction.deleteAll(From(Repo))!;\r\n\r\n    for repoDto: RepoDTO in repos {\r\n        let repo: Repo = transaction.create(Into(Repo));\r\n        repo.populateWithDto(repoDto);\r\n    }\r\n    \r\n    transaction.commit();\r\n});\r\n```\r\n\r\nAnd finally, I can retrieve these data from the database through the following call:\r\n\r\n```swift\r\nDataStoreManager.sharedInstance.dataStack.beginAsynchronous { (transaction) -> Void in\r\n    let repos: Array<Repo> = transaction.fetchAll(From(Repo))!;\r\n    // deal with data...\r\n}\r\n```\r\n\r\n## Make thinner view controllers\r\n\r\nOne of the most common issues in iOS development is a view controller becoming more and more massive.\r\nEspecially, when using a `UITableView`, the view controller inflates hugely (considering _dataSource_ and _delegate_ methods).\r\n\r\nThere already are articles talking about techniques to refactor code of view controllers:\r\n\r\n* <https://www.objc.io/issues/1-view-controllers/lighter-view-controllers/>\r\n* <http://clean-swift.com/refactoring-table-view-data-source-and-delegate-methods/>\r\n\r\nAnother way to slim it down is to focus on business (specific) code and to delegate the boilerplate code to a useful library: [Hakuba](https://github.com/nghialv/Hakuba).\r\n\r\nThe main idea is to remove the `UITableViewDataSource` and `UITableViewDelegate` protocols from our view controller.\r\nAn instance of `Hakuba` will do this job for us.\r\nBut we have to configure this instance so that it can achieve this goal.\r\n\r\nFirst, as usual, we will have to define a `UITableViewCell` subclass with its corresponding `.xib` file. But this time, it has to subclass `MYTableViewCell`.\r\n\r\nThe next step is to define a model class that extends `MYCellModel`. Here we want to display a label and load an image from a remote URL. So, our model is the following:\r\n\r\n```swift\r\nclass RepoCellModel : MYCellModel {\r\n    let avatarUrl: String;\r\n    let name: String;\r\n    \r\n    init(\r\n        avatarUrl: String,\r\n        name: String,\r\n        selectionHandler: MYSelectionHandler) {\r\n            \r\n            self.avatarUrl = avatarUrl;\r\n            self.name = name;\r\n            \r\n            super.init(cell: RepoCell.self, height: 57, selectionHandler: selectionHandler)\r\n    }\r\n}\r\n```\r\n\r\nAnd our cell just has to override the `configureCell` function as follows:\r\n\r\n```swift\r\nclass RepoCell: MYTableViewCell {\r\n    \r\n    @IBOutlet weak var imageViewAvatar: UIImageView!\r\n    @IBOutlet weak var labelName: UILabel!\r\n    \r\n    override func configureCell(cellModel: MYCellModel) {\r\n        super.configureCell(cellModel);\r\n        \r\n        if let repoCellModel: RepoCellModel = (cellModel as? RepoCellModel) {\r\n            \r\n            imageViewAvatar.kf_setImageWithURL(NSURL(string: repoCellModel.avatarUrl)!,\r\n                placeholderImage: UIImage(named: \"Git_icon\"),\r\n                optionsInfo: [.Transition(ImageTransition.Fade(1))]\r\n            );\r\n            \r\n            imageViewAvatar.kf_showIndicatorWhenLoading = true;\r\n            \r\n            labelName.text = repoCellModel.name;\r\n            \r\n        }\r\n    }\r\n}\r\n```\r\n\r\nN.B.: here we use the popular and powerful [Kingfisher](https://github.com/onevcat/Kingfisher) library to download image from a remote URL.\r\n\r\nIn fact, here is just what I could call a \"good practice\" for code structure with a relevant template of \"MV\" part of the \"MVC\" pattern.\r\n\r\nBut now come the great benefits of Hakuba: let's go into the view controller.\r\n\r\nThe first point is that we don't have to subclass the `UITableViewController` and override the _dataSource_ and _delegate_ methods anymore.\r\nWe just define an outlet for our table view. To populate it, we simply define, for each row to display, an instance of our `RepoCellModel` and set it to the main section of our table view thanks to the `Hakuba` instance. Here is the code:\r\n\r\n```swift\r\nfunc resetRepoCellModels() {\r\n    var cellModels: Array<RepoCellModel> = Array<RepoCellModel>();\r\n\r\n    for repo: Repo in self.data {\r\n        let cellModel: RepoCellModel = RepoCellModel(avatarUrl: repo.avatarUrl!, name: repo.name!) { _ in\r\n            print(\"on click item\");\r\n        };\r\n    \r\n        cellModels.append(cellModel);\r\n    }\r\n    \r\n    self.hakuba[0].reset(cellModels)\r\n        .slide(.Fade);\r\n}\r\n```\r\n\r\nConclusion: the rows are displayed in our table view with a nice fade transition and the click event is managed by `Hakuba`, calling the selection handler we've defined. \r\n\r\nTarget met: our view controller is definitely thinner!\r\n\r\n## The VIPER architecture\r\n\r\nKey concepts to grasp in this section are the following:\r\n\r\n* Single responsability principle\r\n   * <http://www.objectmentor.com/resources/articles/srp.pdf>\r\n* Test driven development (TDD)\r\n* Behavior driven development (BDD)\r\n* Protocol-Oriented Programming (POP)\r\n    * <https://developer.apple.com/videos/play/wwdc2015-408/>\r\n    * <http://code.tutsplus.com/tutorials/protocol-oriented-programming-in-swift-2--cms-24979>\r\n\r\nThis section is mainly based on the following article [<https://www.objc.io/issues/13-architecture/viper/>].\r\n\r\n### But what is VIPER?\r\n\r\n> VIPER is an application of [Clean Architecture](https://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html) to iOS apps. The word VIPER is a backronym for View, Interactor, Presenter, Entity, and Routing.\r\n\r\n![VIPER scheme](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/scheme_viper.jpg)\r\n\r\nThe first assessments we could establish after looking at Apple’s ViewController design are the following:\r\n\r\n> * It has multi responsibility (data sourcing, delegation, view interaction, data presentation).\r\n> * Commonly, it is business logic in developers’ mind.\r\n> * It's tightly coupled to the view (it manages a specific lifecycle).\r\n\r\nLeading to a massive file that is very difficult (impossible?) to test.\r\n\r\nIt's commonly hard to understand and review the code of these classes.\r\n\r\nThe main idea of the clean architecture is to structure the code to distinguish:\r\n\r\n* the framework we are leaning on,\r\n* the UI we present to the end user,\r\n* the external entities (coming from a remote server for example).\r\n\r\nFollowing these principles, the code becomes:\r\n\r\n* easy to read,\r\n* easy to understand, \r\n* easy to test, \r\n* easy to maintain.\r\n\r\nAnd thanks to the VIPER architecture, we are now considering a new unmentioned issue: the navigation (the way we are routing between screens).\r\n\r\nSo, the key concepts to understund concerning VIPER are:\r\n\r\n* Module    \r\n    * It gathers all the VIPER concepts to a specific place that corresponds to a specific use case of the application\r\n* View\r\n    * Shows content provided by the presenter\r\n    * Catches user's interactions and notifies it to the presenter\r\n* Presenter\r\n    * Knows nothing about the UI but knows the logic to format data to display\r\n    * Is notified by the view about actions and dispatch them such as:\r\n        * a navigation should start: it asks to the routing (a.k.a. \"wireframe\")\r\n        * a request should start: it sends this command to the interactor\r\n* Interactor\r\n    * Specific job to respond to a single use case\r\n    * Requests data managers to load data from network and/or from local storage\r\n    * Works with simple objects\r\n* Entities (a.k.a. \"data managers\")\r\n    * Is called by the interactor, handles the job and encapsulates entities to provide it as a result to the interactor\r\n    * Knows if data should be loaded from local storage or from a remote server\r\n* Routing (a.k.a. \"wireframe\")\r\n    * Is responsible for setting up all the pieces of a given module\r\n    * Knows how to navigate from this module\r\n    * Is responsible for transitions animations\r\n\r\nA convenient way to write a new module is to begin by developing its interactor first, and then the presenter.\r\n\r\nIt's very easy to test since we could test each concept independently, and we just have to provide \"mock\" objects for the concepts it interacts with.\r\n\r\nAn elegant tool to set up modules easily is \"Boa\" (<https://github.com/team-supercharge/boa>).\r\nWith a simple command line, we can add a new module to our project.\r\nIt's pretty much the same as the \"Viper Module Generator\" (<https://github.com/teambox/viper-module-generator>). Both are relevant. Both are complementary as well. The first provides a common structure for all the modules, and then the dedicated folders for each module. The second sets up a clear distinction between the local data manager and the API data manager.\r\n\r\nI'll combine these tools by adding a new module using \"Boa\" and distinguishing data managers in the \"Viper Module Generator\" way.\r\n\r\nLet's add our first module:\r\n\r\n* we go to the root directory of our project\r\n* enter the project directory\r\n* type the following command line to start a \"Boa\" project:\r\n\r\n```\r\n$ boa init\r\n```\r\n\r\n* fill the form with specific information about the project\r\n* type the following command line to add a specific module\r\n\r\n```\r\n$ vipergen generate ListRepoModule --path=.\r\n```\r\n\r\n* add it to the Xcode project structure (with the \"Copy items if needed\" checked)\r\n\r\nAnd here we have a clear and clean code structure, providing all we need to develop our use cases.\r\n\r\nAs a way to communicate between interactors and data stores, I'll define such \"callback\" enum:\r\n\r\n```swift\r\nenum ListRepoModuleLocalDataManagerDeleteReposResult {\r\n    case Success(deleted: NSNumber);\r\n    case Failure(error: NSError);\r\n}\r\n```\r\n\r\nand then declare the function with a callback parameter as follows:\r\n\r\n```swift\r\nfunc deleteRepos(user: String, completionHandler: (ListRepoModuleLocalDataManagerDeleteReposResult) -> Void);\r\n```\r\n\r\nThat will be called like this:\r\n\r\n```swift\r\nlocalDatamanager?.deleteRepos(user) {\r\n    [unowned self](result) -> Void in\r\n\r\n    switch(result) {\r\n        case .Success(_):\r\n            self.saveRepos(user, repos: repos, pulledToRefresh: pulledToRefresh);\r\n            break;\r\n        case .Failure(let error):\r\n            self.presenter?.presentError(error);\r\n            break;\r\n        }\r\n    }\r\n```\r\n\r\nFollowing POP guidelines, we'll be able to test such piece of code easily by mocking function and providing results.\r\n\r\n## Unit testing\r\n\r\nLet's talk about testing now. Here I introduced two coupled libraries: [Nimble](https://github.com/Quick/Nimble) (for fluent assertions API) and [Quick](https://github.com/Quick/Quick) (to write tests in a BDD way).\r\n\r\n![Quick logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_quick.png)\r\n\r\nI'll present them through a concrete test case of the `ListRepoModuleInteractor` class.\r\n\r\nThanks to the VIPER architecture, I'll mock all the surrounding concepts (`Presenter`, `DataManager`) to achieve the expected behavior.\r\n\r\nSo, I begin by writing the skeleton of my test case:\r\n\r\n```swift\r\nclass SpecListRepoModuleInteractor: QuickSpec {\r\n    \r\n    override func spec() {\r\n        context(\"if it is the perfect nominal case\") {\r\n            it(\"needs to call all the functions in the scenario\") {\r\n                // write assertions\r\n            }\r\n        }\r\n    }\r\n    \r\n}\r\n```\r\n\r\nFirst, we must inherit from the `QuickSpec` class (that itself extends `XCTestCase` class).\r\nThen, we have to override the `spec()` function so that our tests are launched. Now we could write the tests in the BDD way (describing the context, the needs and writing the suitable assertions).\r\n\r\nNow, we need to mock the playing components. Thanks to the POP, I simply have to respond to the specified protocols.\r\n\r\n* The presenter:\r\n\r\n```swift\r\nclass Mock_ListRepoModulePresenter: ListRepoModuleInteractorOutputProtocol {\r\n    init() {}\r\n    \r\n    var presentLoadingFromNetworkWasCalled: Bool = false;\r\n    var presentLoadingFromNetworkPulledToRefresh: Bool = false;\r\n    func presentLoadingFromNetwork(pulledToRefresh: Bool) {\r\n        presentLoadingFromNetworkWasCalled = true;\r\n        presentLoadingFromNetworkPulledToRefresh = pulledToRefresh;\r\n    }\r\n    \r\n    var presentLoadingFromDatabaseWasCalled: Bool = false;\r\n    var presentLoadingFromDatabasePulledToRefresh: Bool = false;\r\n    func presentLoadingFromDatabase(pulledToRefresh: Bool) {\r\n        presentLoadingFromDatabaseWasCalled = true;\r\n        presentLoadingFromDatabasePulledToRefresh = pulledToRefresh;\r\n    }\r\n    \r\n    var presentReposWasCalled: Bool = false;\r\n    var presentReposRepos: Array<Repo> = [];\r\n    var presentReposPulledToRefresh: Bool = false;\r\n    func presentRepos(repos: Array<Repo>, pulledToRefresh: Bool) {\r\n        presentReposWasCalled = true;\r\n        presentReposRepos = repos;\r\n        presentReposPulledToRefresh = pulledToRefresh;\r\n    }\r\n    \r\n    var presentErrorWasCalled: Bool = false;\r\n    func presentError(error: NSError) {\r\n        presentErrorWasCalled = true;\r\n    }\r\n}\r\n```\r\n\r\n* The API data manager:\r\n\r\n```swift\r\nclass Mock_ListRepoModuleAPIDataManager: ListRepoModuleAPIDataManagerInputProtocol {\r\n    \r\n    var mockRepos: Array<RepoDTO> = Array<RepoDTO>();\r\n    init() {\r\n        let repo: RepoDTO = RepoDTO();\r\n        repo.id = 1;\r\n        repo.name = \"test\";\r\n        \r\n        mockRepos.append(repo);\r\n    }\r\n    \r\n    var getReposWasCalled: Bool = false;\r\n    var getReposUser: String = \"\";\r\n    func getRepos(user: String, completionHandler: (ListRepoModuleAPIDataManagerGetReposResult) -> Void) {\r\n        getReposWasCalled = true;\r\n        getReposUser = user;\r\n        \r\n        // returns mock repos\r\n        completionHandler(ListRepoModuleAPIDataManagerGetReposResult.Success(repos: self.mockRepos));\r\n    }\r\n}\r\n```\r\n\r\n* The local data manager:\r\n\r\n```swift\r\nclass Mock_ListRepoModuleLocalDatamanager: ListRepoModuleLocalDataManagerInputProtocol {\r\n    var mockRepos: Array<Repo> = Array<Repo>();\r\n    init() {\r\n        let repo: Repo = Repo();\r\n        mockRepos.append(repo);\r\n    }\r\n    \r\n    var deleteReposWasCalled: Bool = false;\r\n    var deleteReposUser: String = \"\";\r\n    func deleteRepos(user: String, completionHandler: (ListRepoModuleLocalDataManagerDeleteReposResult) -> Void) {\r\n        deleteReposWasCalled = true;\r\n        deleteReposUser = user;\r\n        completionHandler(ListRepoModuleLocalDataManagerDeleteReposResult.Success(deleted: 1));\r\n    }\r\n    \r\n    var saveReposWasCalled: Bool = false;\r\n    func saveRepos(repos: Array<RepoDTO>, completionHandler: (ListRepoModuleLocalDataManagerSaveReposResult) -> Void) {\r\n        saveReposWasCalled = true;\r\n        completionHandler(ListRepoModuleLocalDataManagerSaveReposResult.Success());\r\n    }\r\n    \r\n    var getReposWasCalled: Bool = false;\r\n    var getReposUser: String = \"\";\r\n    func getRepos(user: String, completionHandler: (ListRepoModuleLocalDataManagerGetReposResult) -> Void) {\r\n        getReposWasCalled = true;\r\n        getReposUser = user;\r\n        \r\n        // returns mock repos\r\n        completionHandler(ListRepoModuleLocalDataManagerGetReposResult.Success(repos: self.mockRepos));\r\n    }\r\n}\r\n```\r\n\r\nAnd now, the `spec` function becomes the following:\r\n\r\n```swift\r\noverride func spec() {\r\n    describe(\"When user asks for loading repos\") {\r\n        context(\"and when it is the perfect nominal case\") {\r\n            let interactor: ListRepoModuleInteractorInputProtocol = ListRepoModuleInteractor();\r\n            let presenter: Mock_ListRepoModulePresenter = Mock_ListRepoModulePresenter();\r\n            let APIDataManager: Mock_ListRepoModuleAPIDataManager = Mock_ListRepoModuleAPIDataManager();\r\n            let localDatamanager: Mock_ListRepoModuleLocalDatamanager = Mock_ListRepoModuleLocalDatamanager();\r\n            \r\n            beforeEach {\r\n                // given\r\n                interactor.presenter = presenter;\r\n                interactor.APIDataManager = APIDataManager;\r\n                interactor.localDatamanager = localDatamanager;\r\n                \r\n                // when\r\n                interactor.loadRepos(\"test\", pulledToRefresh: false);\r\n            }\r\n            \r\n            it(\"needs to call all the functions in the scenario\") {\r\n                // then\r\n                \r\n                // APIDataManager\r\n                expect(APIDataManager.getReposWasCalled).to(beTrue());\r\n                expect(APIDataManager.getReposUser).to(equal(\"test\"));\r\n                \r\n                // localDatamanager\r\n                expect(localDatamanager.deleteReposWasCalled).to(beTrue());\r\n                expect(localDatamanager.deleteReposUser).to(equal(\"test\"));\r\n                \r\n                expect(localDatamanager.saveReposWasCalled).to(beTrue());\r\n                \r\n                expect(localDatamanager.getReposWasCalled).to(beTrue());\r\n                expect(localDatamanager.getReposUser).to(equal(\"test\"));\r\n                \r\n                // presenter\r\n                expect(presenter.presentLoadingFromNetworkWasCalled).to(beTrue());\r\n                expect(presenter.presentLoadingFromNetworkPulledToRefresh).to(beFalse());\r\n                \r\n                expect(presenter.presentLoadingFromDatabaseWasCalled).to(beTrue());\r\n                expect(presenter.presentLoadingFromDatabasePulledToRefresh).to(beFalse());\r\n                \r\n                expect(presenter.presentReposWasCalled).to(beTrue());\r\n                expect(presenter.presentReposRepos).to(equal(localDatamanager.mockRepos));\r\n                expect(presenter.presentReposPulledToRefresh).to(beFalse());\r\n                \r\n                expect(presenter.presentErrorWasCalled).to(beFalse());\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nAnd all the assertions pass successfully!\r\n\r\n> A little note about mocking in Swift is that we could have a look to the following library: <https://github.com/mflint/SwiftMock>. It's still under development but it provides a great answer to the traditional mocking and stubbing requirements when writing tests.\r\n\r\n## Conclusion\r\n\r\nAll these tools/libraries combined together lead us to a clear, clean, reliable and testable project template where we can add and maintain features (i.e. modules) easily, in a very intelligible way. \r\nWhat we've got is a robust arsenal of components that are interchangeable if needed.\r\n\r\n## Relevant libraries\r\n\r\n### Kingfisher: <https://github.com/onevcat/Kingfisher>\r\n\r\n> A lightweight and pure Swift implemented library for downloading and caching image from the web.\r\n\r\n![Kingfisher logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_kingfisher.png)\r\n\r\n### Async: <https://github.com/duemunk/Async>\r\n\r\n> Syntactic sugar in Swift for asynchronous dispatches in Grand Central Dispatch ([GCD](https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html))\r\n\r\n### Dollar.swift: <https://github.com/ankurp/Dollar.swift>\r\n\r\n> A functional tool-belt for Swift Language similar to Lo-Dash or Underscore.js in Javascript <http://www.dollarswift.org>\r\n\r\n### ExSwift: <https://github.com/pNre/ExSwift>\r\n\r\n> A set of Swift extensions for standard types and classes.\r\n\r\n### netfox: <https://github.com/kasketis/netfox>\r\n\r\n> A lightweight, one line setup, iOS network debugging library!\r\n\r\n![netfox logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_netfox.png)\r\n\r\n### QorumLogs: <https://github.com/goktugyil/QorumLogs>\r\n\r\n> Swift Logging Utility for Xcode & Google Docs\r\n\r\n### SnapKit: <https://github.com/SnapKit/SnapKit>\r\n\r\n> A Swift Autolayout DSL for iOS & OS X <http://snapkit.io>\r\n\r\n![SnapKit logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_snapkit.png)\r\n\r\n### PKHUD: <https://github.com/pkluz/PKHUD>\r\n\r\n> A Swift based reimplementation of the Apple HUD (Volume, Ringer, Rotation,…) for iOS 8.\r\n\r\n![PKHUD logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_pkhud.png)\r\n\r\n### StatefulViewController: <https://github.com/aschuch/StatefulViewController>\r\n\r\n> Placeholder views based on content, loading, error or empty states\r\n\r\n### UIColor+Hex, now Swift.: <https://github.com/yeahdongcn/UIColor-Hex-Swift>\r\n\r\n> Convenience method for creating autoreleased color using RGBA hex string.\r\n\r\n### AppVersionMonitor: <https://github.com/muukii/AppVersionMonitor>\r\n\r\n> Monitor iOS app version easily.\r\n\r\n### KeyboardObserver: <https://github.com/morizotter/KeyboardObserver>\r\n\r\n> Monitor iOS app version easily.\r\n\r\n### Eureka: <https://github.com/xmartlabs/Eureka>\r\n\r\n> Elegant iOS form builder in Swift 2\r\n\r\n![Eureka logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_eureka.png)\r\n\r\n### Former: <https://github.com/ra1028/Former>\r\n\r\n> Former is a fully customizable Swift2 library for easy creating UITableView based form.\r\n\r\n![Former logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_former.png)\r\n\r\n### SwiftyUserDefaults 2.0: <https://github.com/radex/SwiftyUserDefaults>\r\n\r\n> Statically-typed NSUserDefaults <http://radex.io/swift/nsuserdefaults/static>\r\n\r\n### SwiftKeychainWrapper: <https://github.com/jrendel/SwiftKeychainWrapper>\r\n\r\n> A simple static wrapper for the iOS Keychain to allow you to use it in a similar fashion to user defaults. Written in Swift.\r\n\r\n### CryptoSwift: <https://github.com/krzyzanowskim/CryptoSwift>\r\n\r\n> Crypto related functions and helpers for Swift implemented in Swift programming language <http://krzyzanowskim.com>\r\n\r\n### Prephirences: <https://github.com/phimage/Prephirences>\r\n\r\n> Prephirences is a Swift library that provides useful protocols and convenient methods to manage application preferences, configurations and app-state.\r\n\r\n![Prephirences logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_prephirences.png)\r\n\r\n### CryptoPrephirences: <https://github.com/phimage/CryptoPrephirences>\r\n\r\n> Add some encryption to your sensitive preferences\r\n\r\n### Validator: <https://github.com/adamwaite/Validator>\r\n\r\n> Drop in user input validation for your iOS apps.\r\n\r\n### Gaikan: <https://github.com/akane/Gaikan>\r\n\r\n> Declarative view styling in Swift. Inspired by CSS modules.\r\n\r\n![Gaikan logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_gaikan.png)\r\n\r\n### TRON: <https://github.com/MLSDev/TRON>\r\n\r\n> Lightweight network abstraction layer, written on top of Alamofire\r\n\r\n![TRON logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_tron.png)\r\n\r\n### BNR Core Data Stack: <https://github.com/bignerdranch/CoreDataStack>\r\n\r\n> The Big Nerd Ranch Core Data Stack\r\n\r\n### Duration: <https://github.com/SwiftStudies/Duration>\r\n\r\n> A simple Swift package for measuring and reporting the time taken for operations\r\n\r\n### EasyPeasy: <https://github.com/nakiostudio/EasyPeasy>\r\n\r\n> Auto Layout made easy\r\n\r\n![EasyPeasy logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_easypeasy.png)\r\n\r\n### Palau: <https://github.com/symentis/Palau>\r\n\r\n> NSUserDefaults with Wings!\r\n\r\n![Palau logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_palau.png)\r\n\r\n\r\n## Relevant tools\r\n\r\n### SwiftGen: <https://github.com/AliSoftware/SwiftGen>\r\n\r\n> A collection of Swift tools to generate Swift code (enums for your assets, storyboards, Localizable.strings, ...)\r\n\r\n### xcres: <https://github.com/mrackwitz/xcres>\r\n\r\n> xcres searches your Xcode project for resources\r\n\r\n![xcres logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_xcres.png)\r\n\r\n### Boa: <https://github.com/team-supercharge/boa>\r\n\r\n> Boa is a simple Ruby gem to generate VIPER projects and modules\r\n\r\n### Viper Module Generator: <https://github.com/teambox/viper-module-generator>\r\n\r\n> Gem to generate VIPER modules to use them in your Objective-C/Swift projects\r\n\r\n### cocoapods-clean: <https://github.com/BendingSpoons/cocoapods-clean>\r\n\r\n> cocoapods plugin. Remove Podfile.lock, Pods/ and *.xcworkspace.\r\n\r\n### ViewMonitor: <https://github.com/daisuke0131/ViewMonitor>\r\n\r\n> ViewMonitor can measure view positions with accuracy.\r\n\r\n![ViewMonitor logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_viewmonitor.png)\r\n\r\n## Relevant resources\r\n\r\n### Design Patterns implemented in Swift 2: <https://github.com/ochococo/Design-Patterns-In-Swift>\r\n\r\n> Design Patterns implemented in Swift\r\n\r\n### Swift Toolbox: <http://www.swifttoolbox.io/>\r\n\r\n> Swift toolbox is a community-supported catalog \r\nof iOS and OSX libraries written in the \r\nSwift Programming Language.\r\n\r\n![Swift Toolbox logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_swifttoolbox.png)\r\n\r\n### cocoacontrols: <https://www.cocoacontrols.com/>\r\n\r\n![cocoacontrols logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_cocoacontrols.png)\r\n\r\n### IBM Swift Package Catalog: <https://swiftpkgs.ng.bluemix.net/>\r\n\r\n### iOS Cookies: <http://www.ioscookies.com/>\r\n\r\n> A hand curated collection of iOS libraries written in Swift\r\n\r\n![iOS Cookies logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_ioscookies.png)\r\n\r\n### awesome-swift: <https://github.com/Wolg/awesome-swift>\r\n\r\n> A curated list of awesome Swift frameworks, libraries and software.\r\n\r\n### awesome-swift: <https://github.com/matteocrippa/awesome-swift>\r\n\r\n> A collaborative list of awesome swift resources. Feel free to contribute!\r\n\r\n### CodePath iOS Guides: <http://guides.codepath.com/ios>\r\n\r\n![CodePath logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_codepath.png)\r\n\r\n### iOS Good Practices: <https://github.com/futurice/ios-good-practices>\r\n\r\n> Good ideas for iOS development, by Futurice developers. <http://www.futurice.com>\r\n\r\n![futurice logo](https://raw.githubusercontent.com/RoRoche/iOSSwiftStarter/master/assets/logo_futurice.png)\r\n\r\n### Clean Swift: <http://clean-swift.com/>\r\n\r\n### Awesome-Swift-Education: <https://github.com/hsavit1/Awesome-Swift-Education>\r\n\r\n> All the resources for Learning About Swift\r\n\r\n### Awesome-Apple: <https://github.com/joeljfischer/awesome-apple>\r\n\r\n> An opinionated, curated list of awesome libraries, plugins, and resources for Apple platform development\r\n\r\n### The Official raywenderlich.com Swift Style Guide: <https://github.com/raywenderlich/swift-style-guide>\r\n\r\n> The official Swift style guide for raywenderlich.com.\r\n\r\n### ios-architecture: <https://github.com/onmyway133/ios-architecture>\r\n\r\n> Better ways to structure apps\r\n\r\n## Bibliography\r\n\r\n* ActiveRecord pattern:\r\n\t* <http://www.martinfowler.com/eaaCatalog/activeRecord.html>\r\n* DAO Pattern:\r\n\t* <http://www.oracle.com/technetwork/java/dataaccessobject-138824.html>\r\n* DTO Pattern:\r\n\t* <http://martinfowler.com/eaaCatalog/dataTransferObject.html>\r\n* Singleton in Swift:\r\n\t* <http://krakendev.io/blog/the-right-way-to-write-a-singleton>\r\n* Swift extensions:\r\n\t* <http://www.iphonelife.com/blog/31369/swift-programming-101-power-extensions>\r\n\t* <http://books.aidanf.net/learn-swift/extensions>\r\n* Testing\r\n    * <https://medium.com/@MarcioK/how-you-can-test-view-controllers-with-quick-nimble-328f895b55ee#.nbzec17q4>\r\n    * <http://natashatherobot.com/unit-testing-in-swift-a-quick-look-at-quick/>\r\n* VIPER architecture\r\n    * <https://mutualmobile.github.io/blog/2013/12/04/viper-introduction/>\r\n    * <https://www.objc.io/issues/13-architecture/viper/>\r\n    * <https://github.com/mutualmobile/VIPER-SWIFT>\r\n    * <http://ppinera.es/2014/11/16/viper-looking-for-the-perfect-architecture.html>\r\n    * Automatic VIPER modules generation: <https://medium.com/@Supercharge/generating-viper-modules-with-boa-e8d9f090966b#.egnqwjp07>\r\n\r\n## Bonus\r\n\r\n* iOS Unit Testing: Dependency Injection with Structs in Swift\r\n\t* <http://natashatherobot.com/ios-unit-testing-dependency-injection-with-structs-in-swift/>\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}